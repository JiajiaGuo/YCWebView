#### 基础使用目录介绍
- 05.针对webView视频播放演变
- 06.关于webView拦截缓存处理
- 07.关于shouldOverrideUrlLoading处理多类型




### 05.针对webView视频播放演变
- 1.最刚开始把视频全屏show和hide的逻辑都放到X5WebChromeClient中处理，相当于这个类中逻辑比较多
- 2.后期把视频全屏播放逻辑都抽到了VideoWebChromeClient类中处理，这样只需要继承该类即可。这个类独立，拿来即用。
- 3.后期演变，一个视频全屏播放接口 + 接口实现类 + VideoChromeClient，接口主要能够解耦


### 06.关于webView拦截缓存处理
- 1.最开始把拦截的逻辑都放到X5WebViewClient类中的shouldInterceptRequest方法中。后期演变抽取+接口
- 2.代码结构大概是：拦截缓存接口 + 接口实现类 + 接口委派类
- 3.优点：委派类和实现类解耦；便于增加过滤功能(比如用了https+dns优化就不用拦截缓存)；
    ```
    //1.创建委托对象
    WebViewCacheDelegate webViewCacheDelegate = WebViewCacheDelegate.getInstance();
    //2.通过委托对象调用方法
    WebResourceResponse webResourceResponse = webViewCacheDelegate.interceptRequest(url);
    ```
- 接口(WebViewRequestClient)和实现(WebViewCacheWrapper)相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。


### 07.关于shouldOverrideUrlLoading处理多类型
- 比如：封装库中需要处理打电话，发短信，发邮件，地图定位，图片，超链接等拦截逻辑。还有关于在shouldOverrideUrlLoading拦截做js交互的逻辑……可以说最开始这个类代码很臃肿！
- 最刚开始是把处理的逻辑都放到了WebViewClient中的shouldOverrideUrlLoading方法中处理。不过发现这个类代码越来越多……
- 后期演变，针对电话短信等将处理逻辑抽取到WebSchemeIntent类中，针对图片处理逻辑抽取到SaveImageProcessor类中。具体看[WebSchemeIntent](https://github.com/yangchong211/YCWebView/blob/master/WebViewLib/src/main/java/com/ycbjie/webviewlib/helper/WebSchemeIntent.java)
- 后期演变，将js操作单独抽取出来写到JsX5WebViewClient，这样极大提高了阅读性，类的结构也是更加清晰呢
- 这样做，相当于保证了类的单一性职责，即类尽量保证内部处理的功能尽可能单一，而不是错综复杂……



### 15.其他的一些感受
- 合理使用注解限定符，比如InterWebListener接口中的showErrorView方法，异常的类型可能会出现多种，设置type如果是1，2，3等容易让人看不懂。这时候限定符就发挥作用呢！
- 项目库中如果有和业务代码交接的地方，可以通过接口暴露出来，这样避免了功能和业务耦合，增强了拓展性
- 对于某些不想让别人修改或者继承的类，可以使用finial修饰。比如有赞webView的sdk中，比如ChromeClientWrapper继承了WebChromeClient，为了避免内部不被修改和反射。
- 有抽象意识、封装意识、接口意识。接口的定义只表明做什么，而不是怎么做。在设计接口的时候，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。





