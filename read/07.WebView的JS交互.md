#### 基础使用目录介绍
- 01.js交互介绍说明
- 02.Android调用Js
- 03.Js调用Android
- 04.js调用时机分析
- 05.可能存在的问题分析
- 06.@JavascriptInterface注解方法注意点




### 01.js交互介绍说明
- Java调用js方法有两种：
    - WebView.loadUrl("javascript:" + javascript);
    - WebView.evaluateJavascript(javascript, callback);
- js调用Java的方法有四种，分别是：
    - JavascriptInterface
    - WebViewClient.shouldOverrideUrlLoading()
    - WebChromeClient.onJsPrompt()


### 02.Android调用Js
#### 2.1 使用loadUrl
- 第一种方式：native 调用 js 的方法，方法为：
- 注意的是名字一定要对应上，要不然是调用不成功的，而且还有一点是 JS 的调用一定要在 onPageFinished 函数回调之后才能调用，要不然也是会失败的。
    ```
    //java
    //调用无参方法
    mWebView.loadUrl("javascript:callByAndroid()");
    //调用有参方法
    mWebView.loadUrl("javascript:showData(" + result + ")");
    
    //javascript，下面是对应的js代码
    <script type="text/javascript">
    
    function showData(result){
        alert("result"=result);
        return "success";
    }
    
    function callByAndroid(){
        console.log("callByAndroid")
        showElement("Js:无参方法callByAndroid被调用");
    }
    </script>
    ```


#### 2.2 使用evaluateJavascript
- 如果现在有需求，我们要得到一个 Native 调用 Web 的回调怎么办，Google 在 Android4.4 为我们新增加了一个新方法。
    - 这个方法比 loadUrl 方法更加方便简洁，而且比 loadUrl 效率更高，因为 loadUrl 的执行会造成页面刷新一次，这个方法不会，因为这个方法是在 4.4 版本才引入的，所以使用的时候需要添加版本的判断：
    ```
    if (Build.VERSION.SDK_INT < 18) {
        mWebView.loadUrl(jsStr);
    } else {
        mWebView.evaluateJavascript(jsStr, new ValueCallback<String>() {
            @Override
            public void onReceiveValue(String value) {
                //此处为 js 返回的结果
            }
        });
    }
    ```
- 思考为何效率更高？高在哪里？



#### 2.3 两种方式对比分析
- 两种方式的对比
    - 一般最常使用的就是第一种方法，但是第一种方法获取返回的值比较麻烦，而第二种方法由于是在 4.4 版本引入的，所以局限性比较大。
- 注意问题
    - 记得添加ws.setJavaScriptEnabled(true)代码




### 03.Js调用Android
#### 3.1 addJavascriptInterface
- 第一种方式：通过 addJavascriptInterface 方法进行添加对象映射
    - 这种是使用最多的方式了，首先第一步我们需要设置一个属性：
    ```
    mWebView.getSettings().setJavaScriptEnabled(true);
    ```
- 这个函数会有一个警告，因为在特定的版本之下会有非常危险的漏洞，设置完这个属性之后，Native需要定义一个类：
    - 在 API17 版本之后，需要在被调用的地方加上 @addJavascriptInterface 约束注解，因为不加上注解的方法是没有办法被调用的
    ```
    public class JSObject {
        private Context mContext;
        public JSObject(Context context) {
            mContext = context;
        }
    
        @JavascriptInterface
        public String showToast(String text) {
            Toast.show(mContext, text, Toast.LENGTH_SHORT).show();
            return "success";
        }
        
        /**
         * 前端代码嵌入js：
         * imageClick 名应和js函数方法名一致
         *
         * @param src 图片的链接
         */
        @JavascriptInterface
        public void imageClick(String src) {
            Log.e("imageClick", "----点击了图片");
        }
        
        /**
         * 网页使用的js，方法无参数
         */
        @JavascriptInterface
        public void startFunction() {
            Log.e("startFunction", "----无参");
        }
    }

    //特定版本下会存在漏洞，第一个是对象，第二个是名称
    mWebView.addJavascriptInterface(new JSObject(this), "javascriptInterface");
    ```
- JS 代码调用
    - 这种方式的好处在于使用简单明了，本地和 JS 的约定也很简单，就是对象名称和方法名称约定好即可，缺点就是要提到的漏洞问题。
    - 在Js代码中就能直接通过“JSObject”的对象直接调用了该Native的类的方法。
    ```
    function showToast(){
        var result = myObj.showToast("我是来自web的Toast");
    }
    
    function showToast(){
        myObj.imageClick("图片");
    }
    
    function showToast(){
        myObj.startFunction();
    }
    ```



#### 3.2 shouldOverrideUrlLoading
- 这种方式其实实现也很简单，使用的频次也很高，上面介绍到了 WebViewClient 
    - 其中有个回调接口 shouldOverrideUrlLoading (WebView view, String url)) ，就是利用这个拦截 url，然后解析这个 url 的协议。如果发现是我们预先约定好的协议就开始解析参数，执行相应的逻辑。注意这个方法在 API24 版本已经废弃了，需要使用 shouldOverrideUrlLoading (WebView view, WebResourceRequest request)) 替代，使用方法很类似，我们这里就使用 shouldOverrideUrlLoading (WebView view, String url)) 方法来介绍一下：
- 代码很简单，这个方法可以拦截 WebView 中加载 url 的过程，得到对应的 url，我们就可以通过这个方法，与网页约定好一个协议，如果匹配，执行相应操作。
    ```
    public boolean shouldOverrideUrlLoading(WebView view, String url) {
        //假定传入进来的 url = "js://openActivity?arg1=111&arg2=222"，代表需要打开本地页面，并且带入相应的参数
        Uri uri = Uri.parse(url);
        String scheme = uri.getScheme();
        //如果 scheme 为 js，代表为预先约定的 js 协议
        if (scheme.equals("js")) {
              //如果 authority 为 openActivity，代表 web 需要打开一个本地的页面
            if (uri.getAuthority().equals("openActivity")) {
                  //解析 web 页面带过来的相关参数
                HashMap<String, String> params = new HashMap<>();
                Set<String> collection = uri.getQueryParameterNames();
                for (String name : collection) {
                    params.put(name, uri.getQueryParameter(name));
                }
                Intent intent = new Intent(getContext(), MainActivity.class);
                intent.putExtra("params", params);
                getContext().startActivity(intent);
            }
            //代表应用内部处理完成
            return true;
        }
        return super.shouldOverrideUrlLoading(view, url);
    }
    ```
- JS 代码调用
    ```
    function openActivity(){
        document.location = "js://openActivity?arg1=111&arg2=222";
    }
    ```
- 存在问题：这个代码执行之后，就会触发本地的 shouldOverrideUrlLoading 方法，然后进行参数解析，调用指定方法。
    - 这个方式不会存在第一种提到的漏洞问题，但是它也有一个很繁琐的地方是，如果 web 端想要得到方法的返回值，只能通过 WebView 的 loadUrl 方法去执行 JS 方法把返回值传递回去，相关的代码如下：
    ```
    //java
    mWebView.loadUrl("javascript:returnResult(" + result + ")");
    
    //javascript
    function returnResult(result){
        alert("result is" + result);
    }
    ```


#### 3.3 WebChromeClient回调接口
- 利用 WebChromeClient 回调接口的三个方法拦截消息
    - 这个方法的原理和第二种方式原理一样，都是拦截相关接口，只是拦截的接口不一样：
    ```
    @Override
    public boolean onJsAlert(WebView view, String url, String message, JsResult result) {
        return super.onJsAlert(view, url, message, result);
    }
    
    @Override
    public boolean onJsConfirm(WebView view, String url, String message, JsResult result) {
        return super.onJsConfirm(view, url, message, result);
    }
    
    @Override
    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) {
        //假定传入进来的 message = "js://openActivity?arg1=111&arg2=222"，代表需要打开本地页面，并且带入相应的参数
        Uri uri = Uri.parse(message);
        String scheme = uri.getScheme();
        if (scheme.equals("js")) {
            if (uri.getAuthority().equals("openActivity")) {
                HashMap<String, String> params = new HashMap<>();
                Set<String> collection = uri.getQueryParameterNames();
                for (String name : collection) {
                    params.put(name, uri.getQueryParameter(name));
                }
                Intent intent = new Intent(getContext(), MainActivity.class);
                intent.putExtra("params", params);
                getContext().startActivity(intent);
                //代表应用内部处理完成
                result.confirm("success");
            }
            return true;
        }
        return super.onJsPrompt(view, url, message, defaultValue, result);
    }
    ```
- 和 WebViewClient 一样，这次添加的是WebChromeClient接口，可以拦截JS中的几个提示方法，也就是几种样式的对话框，在 JS 中有三个常用的对话框方法： 
    - onJsAlert 方法是弹出警告框，一般情况下在 Android 中为 Toast，在文本里面加入\n就可以换行； 
    - onJsConfirm 弹出确认框，会返回布尔值，通过这个值可以判断点击时确认还是取消，true表示点击了确认，false表示点击了取消； 
    - onJsPrompt 弹出输入框，点击确认返回输入框中的值，点击取消返回 null。
- 但是这三种对话框都是可以本地拦截到的，所以可以从这里去做一些更改，拦截这些方法，得到他们的内容，进行解析，比如如果是 JS 的协议，则说明为内部协议，进行下一步解析然后进行相关的操作即可，prompt 方法调用如下所示：
    ```
    function clickprompt(){
        var result=prompt("js://openActivity?arg1=111&arg2=222");
        alert("open activity " + result);
    }
    ```
    - 需要注意的是 prompt 里面的内容是通过 message 传递过来的，并不是第二个参数的 url，返回值是通过 JsPromptResult 对象传递。
    - 为什么要拦截 onJsPrompt 方法，而不是拦截其他的两个方法，这个从某种意义上来说都是可行的，但是如果需要返回值给 web 端的话就不行了。
    - 因为 onJsAlert 是不能返回值的，而 onJsConfirm 只能够返回确定或者取消两个值，只有 onJsPrompt 方法是可以返回字符串类型的值，操作最全面方便。



#### 3.4 三种方案对比
- 以上三种方案都是可行的，在这里总结一下
- 第一种方式：使用广泛
    - 是现在目前最普遍的用法，方便简洁，但是唯一的不足是在 4.2 系统以下存在漏洞问题；
- 第二种方式：拦截约定规范协议
    - 通过拦截 url 并解析，如果是已经约定好的协议则进行相应规定好的操作，缺点就是协议的约束需要记录一个规范的文档，而且从 Native 层往 Web 层传递值比较繁琐，优点就是不会存在漏洞。
- 第三种方式：拦截3种对话框
    - 和第二种方式的思想其实是类似的，只是拦截的方法变了，这里拦截了 JS 中的三种对话框方法。
    - 而这三种对话框方法的区别就在于返回值问题，alert 对话框没有返回值，confirm 的对话框方法只有两种状态的返回值，prompt 对话框方法可以返回任意类型的返回值。
    - 缺点就是协议的制定比较麻烦，需要记录详细的文档，但是不会存在第二种方法的漏洞问题。
- js调用java方法比较和区别分析
    - 1.通过 addJavascriptInterface 方法进行添加对象映射。js最终通过对象调用原生方法
    - 2.shouldOverrideUrlLoading拦截操作，获取scheme匹配，与网页约定好一个协议，如果匹配，执行相应操作
    - 3.利用WebChromeClient回调接口onJsPrompt拦截操作。
        - onJsAlert 是不能返回值的，而 onJsConfirm 只能够返回确定或者取消两个值，只有 onJsPrompt 方法是可以返回字符串类型的值，操作最全面方便。



### 04.js调用时机分析
- **onPageFinished()或者onPageStarted()方法中注入js代码**
    - 做过WebView开发，并且需要和js交互，大部分都会认为js在WebViewClient.onPageFinished()方法中注入最合适，此时dom树已经构建完成，页面已经完全展现出来。但如果做过页面加载速度的测试，会发现WebViewClient.onPageFinished()方法通常需要等待很久才会回调（首次加载通常超过3s），这是因为WebView需要加载完一个网页里主文档和所有的资源才会回调这个方法。
    - 能不能在WebViewClient.onPageStarted()中注入呢？答案是不确定。经过测试，有些机型可以，有些机型不行。在WebViewClient.onPageStarted()中注入还有一个致命的问题——这个方法可能会回调多次，会造成js代码的多次注入。
    - 从7.0开始，WebView加载js方式发生了一些小改变，**官方建议把js注入的时机放在页面开始加载之后**。
- **WebViewClient.onProgressChanged()方法中注入js代码**
    - WebViewClient.onProgressChanged()这个方法在dom树渲染的过程中会回调多次，每次都会告诉我们当前加载的进度。
        - 在这个方法中，可以给WebView自定义进度条，类似微信加载网页时的那种进度条
        - 如果在此方法中注入js代码，则需要避免重复注入，需要增强逻辑。可以定义一个boolean值变量控制注入时机
    - 那么有人会问，加载到多少才需要处理js注入逻辑呢？
        - 正是因为这个原因，页面的进度加载到80%的时候，实际上dom树已经渲染得差不多了，表明WebView已经解析了<html>标签，这时候注入一定是成功的。在WebViewClient.onProgressChanged()实现js注入有几个需要注意的地方：
        - 1 上文提到的多次注入控制，使用了boolean值变量控制
        - 2 重新加载一个URL之前，需要重置boolean值变量，让重新加载后的页面再次注入js
        - 3 如果做过本地js，css等缓存，则先判断本地是否存在，若存在则加载本地，否则加载网络js
        - 4 注入的进度阈值可以自由定制，理论上10%-100%都是合理的，不过建议使用了75%到90%之间可以。



### 05.可能存在的问题分析
- 提出问题
    - 1.原生方法是否可以执行耗时操作，如果有会阻塞通信吗？
    - 2.多线程中调用多个原生方法，如何保证原生方法每一个都会被执行到？
    - 3.js会阻塞等待当前原生函数（耗时操作的那个）执行完毕再往下走，所以js调用java方法里面最好也不要做耗时操作
- 解决方案
    - 1.在js调用window.alert，window.confirm，window.prompt时，会调用WebChromeClient对应方法，可以此为入口，作为消息传递通道，考虑到开发习惯，一般不会选择alert跟confirm，通常会选prompt作为入口，在App中就是onJsPrompt作为jsbridge的调用入口。由于onJsPrompt是在UI线程执行，所以尽量不要做耗时操作，可以借助Handler灵活处理。
    - 2.利用Handler封装一下，让每个任务自己处理，耗时的话就开线程自己处理。




### 06.@JavascriptInterface注解方法注意点
- 在js调用Android原生方法时，会用@JavascriptInterface注解标注那些需要被调用的Android原生方法，那么思考一下，这些原生方法是否可以执行耗时操作，如果有会阻塞通信吗？
- JS会阻塞等待当前原生函数（耗时操作的那个）执行完毕再往下走，所以 @JavascriptInterface注解的方法里面最好也不要做耗时操作，最好利用Handler封装一下，让每个任务自己处理，耗时的话就开线程自己处理，这样是最好的。
- JavascriptInterface注入的方法被js调用时，可以看做是一个同步调用，虽然两者位于不同线程，但是应该存在一个等待通知的机制来保证，所以Native中被回调的方法里尽量不要处理耗时操作，否则js会阻塞等待较长时间。




### 07.onJsPrompt实现js通信注意点
- 在WvWebView类中，就是使用onJsPrompt实现js调用Android通信，具体可以看一下代码。
- 在js调用window.alert，window.confirm，window.prompt时，会调用WebChromeClient对应方法，可以此为入口，作为消息传递通道。
- 考虑到开发习惯，一般不会选择alert跟confirm，通常会选promopt作为入口，在App中就是onJsPrompt作为jsbridge的调用入口。
- 由于onJsPrompt是在UI线程执行，所以尽量不要做耗时操作，可以借助Handler灵活处理。对于回调的处理跟上面的addJavascriptInterface的方式一样即可
    ```
    @Override
    public boolean onJsPrompt(WebView view, String url, final String message,
                              String defaultValue, final JsPromptResult result) {
        if(Build.VERSION.SDK_INT<= Build.VERSION_CODES.JELLY_BEAN){
            String prefix="_wvjbxx";
            if(message.equals(prefix)){
                Message msg = mainThreadHandler.obtainMessage(HANDLE_MESSAGE, defaultValue);
                mainThreadHandler.sendMessage(msg);
            }
            return true;
        }
        //省略部分代码……
        return true;
    };
    ```
- 然后主线程中处理接受的消息，这里仅仅展示部分代码，具体逻辑请下载demo查看。
    ```
    @SuppressLint("HandlerLeak")
    private class MyHandler extends Handler {
    
        private WeakReference<Context> mContextReference;
    
        MyHandler(Context context) {
            super(Looper.getMainLooper());
            mContextReference = new WeakReference<>(context);
        }
    
        @Override
        public void handleMessage(Message msg) {
            final Context context = mContextReference.get();
            if (context != null) {
                switch (msg.what) {
                    case HANDLE_MESSAGE:
                        WvWebView.this.handleMessage((String) msg.obj);
                        break;
                    default:
                        break;
                }
            }
        }
    }
    ```




### 06.隐藏H5中某标签布局




### 5.0.9 后台无法释放js导致发热耗电
- 在有些手机你如果webView加载的html里，有一些js一直在执行比如动画之类的东西，如果此刻webView 挂在了后台这些资源是不会被释放用户也无法感知。
- 导致一直占有cpu 耗电特别快，所以如果遇到这种情况，处理方式如下所示。大概意思就是在后台的时候，会调用onStop方法，即此时关闭js交互，回到前台调用onResume再开启js交互。
    ```
    //在onStop里面设置setJavaScriptEnabled(false);
    //在onResume里面设置setJavaScriptEnabled(true)。
    @Override
    protected void onResume() {
        super.onResume();
        if (mWebView != null) {
            mWebView.getSettings().setJavaScriptEnabled(true);
        }
    }
    @Override
    protected void onStop() {
        super.onStop();
        if (mWebView != null) {
            mWebView.getSettings().setJavaScriptEnabled(false);
        }
    }
    ```


